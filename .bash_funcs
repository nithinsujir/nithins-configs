#!/bin/bash
CPUS=$(grep processor /proc/cpuinfo | wc -l)
THREADS=$((CPUS*2))
export SSH="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o loglevel=error"
export SCP="scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o loglevel=error"
IRDEXPLODE=/root/initrd_explode
KIRDEXPLODE=/root/kinitrd_explode
BDOM_MNT=/bdom


esn() {
	sudo vim /etc/sysconfig/network-scripts/ifcfg-$1
}

parse_git_branch() {
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'
}

# parent branch
gpb() {
	local cur_branch=$(git rev-parse --abbrev-ref HEAD)
	git show-branch --list | grep -A 1 $cur_branch | tail -n 1 | grep -Po '(?<=\[).*(?=\])'
}

# outgoing changes to parent
gio() {
	local parent_branch=$(gpb)

	if [[ -z $parent_branch ]]; then
		parent_branch="origin"
	fi
	git log $parent_branch.. "$@"
}

# git export outgoing changes
gie() {
	local cur_branch=$(git rev-parse --abbrev-ref HEAD)
	local dest="$HOME/patches/$cur_branch/$(date +'%b-%d__%H.%M')"
	local parent=$(gpb)
	local count=$(git log $(gpb).. | grep ^commit | wc -l)
	mkdir -p $dest
	git format-patch -s -o $dest/ -$count
}

parse_hg_branch() {
    local curdir=`pwd`

    while [ "$curdir" != "/" ]
    do
	    if [ -f "$curdir/.hg/branch" ]
	    then
		    echo "(`cat $curdir/.hg/branch`)"
		    return
	    fi

	    curdir=`dirname "$curdir"`
    done
}

cur_hg_bookmark() {
    local curdir=`pwd`

    while [ "$curdir" != "/" ]
    do
	    if [ -f "$curdir/.hg/bookmarks.current" ]
	    then
		    echo "`cat $curdir/.hg/bookmarks.current`"
		    return
	    fi

	    curdir=`dirname "$curdir"`
    done

}

parse_hg_bookmark() {
	local book=$(cur_hg_bookmark)

	if [[ x$book == x ]] ; then
		return
	fi

	echo "($book)"
}

hgm() {
	hg paths | grep -q tintri

	local BR=(hg branch)

	if [ $BR == "default" ]
	then
		hg up master
	else
		hg up master-$BR
	fi
}

hgmf() {
	local BR=`hg branch`

	if [ $BR == "default" ]
	then
		hg bookmark -f master
	else
		hg bookmark -f master-$BR
	fi
}

hgp() {
	# If branch not passed in use current branch
	local BR=${1:-$( hg branch )}

	for repo in platform fs ui
	do
		pushd $TOPDIR/$repo > /dev/null
		hg up $BR
		hg pull

		hg up $BR
		if [ $BR == "default" ]
		then
			hg bookmarks -f master
		else
			hg bookmarks -f master-$BR
		fi

		popd > /dev/null
	done

	pushd $TOPDIR/plat-os
	hg tupdate
	popd > /dev/null
}

hgt() {
	for repo in platform fs ui oneui
	do
		pushd $TOPDIR/$repo > /dev/null
		hg tupdate
		popd > /dev/null
	done
}

hgbd() {
	hg bookmark -d $(cur_hg_bookmark)
}

HGMF() {
	hgbd
	hgmf
}

hgbr() {
	local BR=$1
	local BR_ROOT=`hg out -r $BR | grep changeset | head -n 1 | awk {'print $2;'}`

	hg rebase -s $BR_ROOT -d .
	hg up $BR
}

hgho() {
	local BR_ROOT=`hg out -r . | grep changeset | head -n 1 | awk {'print $2;'}`
	hg histedit $BR_ROOT
}

cs() {
	rm tags
	rm cscope.*

	find . -name "*.[ch]" | grep -Ev "sound|video|arch.arm|arch.frv|arch.blackfin|arch.cris|arch.microb|arch.powerpc|s390|arch.sh|bluetooth|infiniband|isdn|pcmcia|ceph|btrfs|fs.hfs|fs.hp|fs.jf|fs.ntfs|fs.jbd|fs.min|fs.nil|fs.ocf|fs.xfs|fs.nfs|ubifs|wireless|wimax|chelsio|.fufcache|drivers.media|drivers.input|drivers.atm|drivers.gpu|macintosh|m68k|xtensa|sparc|fs.nls|fs.cifs|squashfs|fs.befs|reiserfs|fs.gfs|fs.dlm|include.media|include.linux.usb|dvb|config.nls|config.media|hisax|usb|config.snd|hid|mellanox|net.ppp|net.hamradio|staging|alpha|avr32|unicore32|mn10300|arch.um|c6x|m32r|hexagon|h8300|parisc|mips|arch.score|openrisc|ia64|arch.tile|adfs|coda|fs.afs|fs.udf|fs.9p|fs.exofs|ncpfs|freevxfs|mfd|linux.input|config.input|mtd|touchscreen|irda|patches|ixgbe-2|ixgbe-3.2|ixgbe-3.3|igb-2|igb-3|mpt2sas-04|mpt2sas-07|scsi.mpt2|netlist-1.4|extdrivers.umx|extdrivers.umem|madura-0.3|kernel-sample|intel.ntb" > cscope.files
	find . -name "*.cpp" >> cscope.files

	/usr/bin/cscope -bv
	ctags -V -L cscope.files

	find {scripts,tools} -type f  -exec grep -Il . {} \; | xargs file | grep -e Bourne -e "POSIX shell" | sed 's/:.*$//'  > cscope.scripts
	ctags -aV -L cscope.scripts
}

rsa() {
	echo "Authorizing on $1"
	pushd $HOME > /dev/null
	cat .ssh/id_rsa.pub | ssh $1 'cat >> .ssh/authorized_keys'
	popd > /dev/null
}

sc() {
	local TRPM=`ls -lt $TOPDIR/distro_bld/local_rpms/RPMS/x86_64/txos*.rpm | awk {'print $8;'} | head -n 1`
	local TVER=`echo $TRPM | sed 's/.*txos-//' | sed 's/.x86.*//'`
	local TREL=/var/ftp/txos_releases
	local TVM="test-vm205"
	local TITN="/tftpboot/images/txos/nsujir"

	echo "Release: $TVER"
	echo "Create remote dir $TREL/$TVER"
	ssh -o loglevel=error root@pxesrv1 mkdir -p $TREL/$TVER
	ssh -o loglevel=error root@pxesrv1 mkdir -p $TITN/$TVER

	echo "scp -o loglevel=error $TRPM root@$TVM:txos/"
	scp -o loglevel=error $TRPM root@$TVM:txos/ &

	echo "scp $TOPDIR/distro_bld/sysimage/boot/vmlinuz root@pxesrv1:$TITN"
	scp -o loglevel=error $TOPDIR/distro_bld/sysimage/boot/vmlinuz root@pxesrv1:$TITN/vmlinuz.$TVER
	ssh -o loglevel=error root@pxesrv1 "/bin/cp -f $TITN/vmlinuz.$TVER $TITN/$TVER/vmlinuz"

	echo "scp -o loglevel=error $TOPDIR/distro_bld/sysimage/boot/initrd root@pxesrv1:$TITN"
	scp -o loglevel=error $TOPDIR/distro_bld/sysimage/boot/initrd root@pxesrv1:$TITN/initrd.$TVER
	ssh -o loglevel=error root@pxesrv1 "/bin/cp -f $TITN/initrd.$TVER $TITN/$TVER/initrd"

	# Setup latest symlinks
	ssh -o loglevel=error root@pxesrv1 "rm -f /tftpboot/images/txos/latest_nsujir"
	ssh -o loglevel=error root@pxesrv1 "rm -f $TREL/latest_nsujir"
	ssh -o loglevel=error root@pxesrv1 "/bin/ln -sf nsujir/$TVER /tftpboot/images/txos/latest_nsujir"
	ssh -o loglevel=error root@pxesrv1 "/bin/ln -sf $TVER $TREL/latest_nsujir"

	echo "scp $TRPM root@pxesrv1:$TREL/$TVER/"
	scp -o loglevel=error $TRPM root@pxesrv1:$TREL/$TVER/

	scp root@pxesrv1:/tftpboot/pxelinux.cfg/nsujir.menu /tmp/
	OTVER=$(grep vmlinuz /tmp/nsujir.menu | head -n 1 | sed 's:.*vmlinuz.::')
	mv /tmp/nsujir.menu /tmp/nsujir.menu.orig

	LABEL=$(date +"%b-%d %k:%M")

	if [[ -n $1 ]]; then
		PREFIX="$1-"
	else
		PREFIX=$(hg bookmark | grep "*" | awk {'print $2'})
		PREFIX="$PREFIX-"
	fi

	if [ $OTVER != $TVER ]; then
		# Need blank line at the end before EOF
		/bin/cat > /tmp/nsujir.menu <<- EOF
			MENU TITLE nsujir menu
			LABEL nsujir $PREFIX$LABEL
				MENU LABEL nsujir $PREFIX$LABEL
				KERNEL images/txos/nsujir/vmlinuz.$TVER
				APPEND initrd=images/txos/nsujir/initrd.$TVER NukeInstall rootpart=1 stable=1 md_uuid=placeholder dev_uuid=placeholder verbose ftpserver=10.10.10.186 installvers=$TVER devpassword=tintri99 nowdog nosec smallmd

		EOF
	fi

	if [ -f /tmp/nsujir.menu.orig ]; then
		/bin/cat /tmp/nsujir.menu.orig >> /tmp/nsujir.menu
	fi

	scp -o loglevel=error /tmp/nsujir.menu root@pxesrv1:/tftpboot/pxelinux.cfg/

	wait
	ssh -o loglevel=error root@$TVM ln -sf txos/txos-${TVER}.x86_64.rpm latest
}

FS() {
	local cid
	local rc=0

	pushd $TOPDIR/fs > /dev/null

	# Check if we need to build. hg identify adds a '+' if there are
	# uncommitted changes so we will always rebuild in that case
	cid=$(hg identify --num)
	ls $TOPDIR/distro_bld/local_rpms/RPMS/x86_64/filesystem_core*$cid*.rpm
	if [[ $? -ne 0 ]]; then
		scons BUILDDIR=$TOPDIR/bld_rs BUILDTYPE=release tree "$@"
		cd $TOPDIR/bld_rs
		scons -j $THREADS src
		rc=$?
	else
		echo "FS already built"
	fi

	popd > /dev/null

	return $rc
}

BE() {
	# Build extpkgs
	pushd $TOPDIR/platform/distro/extpkgs/ > /dev/null

	./build.sh -e build -j $THREADS
	[[ $? -ne 0 ]] && return
	./build.sh -e install
	[[ $? -ne 0 ]] && return

	popd > /dev/null
}

BP() {
	pushd $TOPDIR/platform/os > /dev/null

	# Build os
	./build.sh build -j $THREADS
	[[ $? -ne 0 ]] && return

	./build.sh install
	[[ $? -ne 0 ]] && return

	popd > /dev/null
}

RMS() {
	sudo rm -rf $TOPDIR/distro_bld/sysimage/initrd_image
	sudo rm -rf $TOPDIR/distro_bld/sysimage/boot
}

MK() {
	RMS
	sudo TOPDIR=$TOPDIR $TOPDIR/platform/distro/tools/mkrel -b $TOPDIR -r $TOPDIR/bld_rs -u $TOPDIR/ui -g -J -e devtools -s -E vmlinux -E realstore -E PlatCmd -E HAMon -E nvx -E pmc -E PlatMon -E list_disks -E boot_fsck "$@"
	# -B $TOPDIR/plat-os/fedora12/ 
}

B() {
	pushd $TOPDIR/platform/os > /dev/null

	(
		set -o errexit
		BP
		BE
		RMS
		MK "$@"
	)

	popd > /dev/null
}

UI() {
	local cid
	local rc=0

	pushd $TOPDIR/ui > /dev/null

	# Check if we need to build. hg identify adds a '+' if there are
	# uncommitted changes so we will always rebuild in that case
	cid=$(hg identify --num)
	ls $TOPDIR/distro_bld/local_rpms/RPMS/x86_64/ui_core*$cid*.rpm
	if [[ $? -ne 0 ]]; then
		local branch=$(hg branch)
		local lastcleaned=$(cat $TOPDIR/.last)

		echo "$lastcleaned $branch"

		if [[ $lastcleaned != $branch ]]; then
			./antbuild clean
			./antbuild smis-clean
			rm -rf hyper-v/smis/pegasus_tmp
			hg purge hyper-v/
			hg revert hyper-v/
			echo $(hg branch) > $TOPDIR/.last
		fi

		./antbuild
		rc=$?
	else
		echo "UI already built"
	fi

	popd > /dev/null

	return $rc
}

BFP() {
	diff $TOPDIR/platform/.hg/branch $TOPDIR/fs/.hg/branch
	[[ $? -ne 0 ]] &&  {
		echo "Branches don't match"
		return
	}

	diff $TOPDIR/platform/.hg/branch $TOPDIR/ui/.hg/branch
	[[ $? -ne 0 ]] &&  {
		echo "Branches don't match"
		return
	}

	FS
	[[ $? -ne 0 ]] && return

	B "$@"
}

BPE() {
	(
		set -o errexit

		BP
		BE
	)
}

BT() {
	diff $TOPDIR/platform/.hg/branch $TOPDIR/fs/.hg/branch
	[[ $? -ne 0 ]] &&  {
		echo "Branches don't match"
		return
	}

	diff $TOPDIR/platform/.hg/branch $TOPDIR/ui/.hg/branch
	[[ $? -ne 0 ]] &&  {
		echo "Branches don't match"
		return
	}

	BPE &
	bpid=$!

	FS &
	fpid=$!

	UI
	[[ $? -ne 0 ]] && return

	wait $bpid
	[[ $? -ne 0 ]] && return

	wait $fpid
	[[ $? -ne 0 ]] && return

	MK "$@"
}

TC() {
	rm -rf $TOPDIR/kbuild
	rm -rf $TOPDIR/bld_rs
	sudo rm -rf $TOPDIR/distro_bld
}

BTC() {
	TC
	BT
}

BRC() {
	sudo rm $TOPDIR/distro_bld/local_rpms/RPMS/x86_64/*
	B
}

isol() {
	ipmitool -I lanplus -U admin -P tintri99 -H $1-ipmi -L OPERATOR sol activate
}

isel() {
	ipmitool -I lanplus -U admin -P tintri99 -H $1-ipmi sel list
}

isold() {
	ipmitool -I lanplus -U admin -P tintri99 -H $1-ipmi -L OPERATOR sol deactivate
}

xsol() {
	ipmitool -I lanplus -U admin -P admin -H $1-ipmi sol activate
}

xsel() {
	ipmitool -I lanplus -U admin -P admin -H $1-ipmi sel list
}

xsold() {
	ipmitool -I lanplus -U admin -P admin -H $1-ipmi sol deactivate
}

mbd() {
	mkdir -p $BDOM_MNT

	boot_dom=$(/usr/local/tintri/bin/list_disks -i)
	# On ttvm, list_disks -i will fail
	if [[ -z $boot_dom ]]; then
		boot_dom=/dev/sda
	fi

	mount ${boot_dom}1 $BDOM_MNT
}

ubd() {
	umount $BDOM_MNT
}

iu() {
	local MNT=/media
	mkdir -p $MNT

	boot_dom=$(/usr/local/tintri/bin/list_disks -i)

	# On ttvm, list_disks -i will fail
	if [[ -z $boot_dom ]]; then
		boot_dom=/dev/sda
	fi

	if [ -d $IRDEXPLODE ]
	then
		return
	fi

	mkdir $IRDEXPLODE
	cd $IRDEXPLODE

	mount ${boot_dom}1 $MNT
	INITRD=$( grep initrd $MNT/grub/grub.conf  | /bin/awk -F / {'print $2;'} )
	gunzip -c $MNT/$INITRD | cpio -i
	umount $MNT
	cd -
}

kiu() {
	if [ -d $KIRDEXPLODE ]
	then
		return
	fi

	mkdir $KIRDEXPLODE
	cd $KIRDEXPLODE

	gunzip -c /boot/initrd-$(uname -r)kdump.img | cpio -i
	cd -
}

KIU() {
	rm -rf $KIRDEXPLODE
	kiu
}

liu() {
	local initrd=$(ls -1rt ../initrd* | tail -n 1)
	gunzip -c $initrd | cpio -i
}

IU() {
	local MNT=/media

	rm -rf $IRDEXPLODE

	if grep -q $MNT /proc/mounts; then
		umount $MNT
	fi

	iu
}

iz() {
	local MNT=/media

	if [ ! -d $IRDEXPLODE ]
	then
		echo "initrd not exploded"
		return
	fi

	boot_dom=$(/usr/local/tintri/bin/list_disks -i)

	# On ttvm, list_disks -i will fail
	if [[ -z $boot_dom ]]; then
		boot_dom=/dev/sda
	fi

	mount ${boot_dom}1 $MNT

	cd $IRDEXPLODE
	INITRD=$( grep initrd $MNT/grub/grub.conf  | /bin/awk -F / {'print $2;'} )
	find . | cpio -H newc -o | gzip -1 > $MNT/$INITRD
	umount $MNT
	sync
	cd -
}

kiz() {
	if [ ! -d $KIRDEXPLODE ]
	then
		echo "kdump initrd not exploded"
		return
	fi

	cd $KIRDEXPLODE
	find . | cpio -H newc -o | gzip -1 > /boot/initrd-$(uname -r)kdump.img
	sync
	cd -
}

liz() {
	local initrd=$(ls -1rt ../initrd* | tail -n 1)
	find . | cpio -H newc -o | gzip -1 > $initrd
}

hgl() {
	local rev=.
	local p=

	if [[ ! -z $1 && $1 == "-p" ]]
	then
		p="-p"
		shift
	fi

	if [ ! -z $1 ]
	then
		rev=`hg book | grep " $1 " | awk {'print $2;'}`
		shift
	fi

	# -p can be before or after the rev
	if [[ ! -z $1 && $1 == "-p" ]]
	then
		p="-p"
	fi

	hg log -b . --rev "reverse(ancestors($rev))" $p
}

ff() {
	local repo=$(basename `pwd`)

	if [[ $repo == "os" ]] ; then
		dirs=(
			#extdrivers/lsi/mpt2sas-10.00.00.00/mpt2sas
			../distro/fs_overlay
			../distro/ui_overlay
			../distro/sys_overlay
			../distro/initrd_overlay
			../distro/tools
			../distro/spec
			extdrivers/lsi/mpt3sas-13.255.01.00/mpt3sas/
			extdrivers/intel/enet/ixgbe-3.11.33/src
			extdrivers/nvx
			extdrivers/agiga/madura-1.0/
			extdrivers/agiga/nvdimm_mir
			extdrivers/xyratex/xybridge/
			extdrivers/pmc/PMC_Linux_NVMe_Driver_1_0_1
			extdrivers/diskdump
			extdrivers/hactl
			tools/
			scripts/

		)
	elif [[ $repo == "fs" ]] ; then
		dirs=(
			src/prog/*
			src/lib/*
			src/interface/*
		)
	else
		dirs=( . )
	fi

	rm -rf .fufcache
	rm fuf.files

	mkdir -p .fufcache

	for dirname in ${dirs[@]}; do
		find $dirname/ | xargs file | grep -e program -e script | awk -F : {'print $1;'} >> fuf.files
	done

	cd .fufcache
	for fil in `cat ../fuf.files`; do
		echo $fil
		ln -sf ../$fil .
	done

	cd -
}

hge() {
	local rev_start=`hg outgoing -r . | grep changeset | awk  {'print $2;'} | sed -s "s/:.*$//" | head -n 1`
	local rev_end=`hg outgoing -r . | grep changeset | awk  {'print $2;'} | sed -s "s/:.*$//" | tail -n 1`
	local dest=$HOME/patches/$(cur_hg_bookmark)/`date +"%b-%d__%H.%M"`
	mkdir -p $dest

	hg export -r $rev_start:$rev_end -o "$dest/%n-%m.patch"
	echo "Patches exported to $dest"
}

btools() {
	pushd $TOPDIR/platform/os/tools > /dev/null
	./build.sh build -j $THREADS
	popd > /dev/null
}

tsh() {
	local target=$1

	tsa $target

	shift
	$SSH root@$target $@
}

ish() {
	local target=$1-ipmi
	sshpass  -p superuser ssh -o StrictHostKeyChecking=no sysadmin@$target
}

tcp() {
	local target=$1

	tsa $target

	if [[ ! $1 =~ : ]]; then
		target=$target:
	fi
	shift
	/usr/bin/scp -r -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o loglevel=error "$@" root@$target
}

drpms() {
	du -sh /*/workspaces/*/distro_bld/local_rpms/RPMS
	du -sh /*/workspaces/*/kbuild
	sudo find /*/workspaces/*/distro_bld/local_rpms/RPMS -iname "*.rpm" -mtime +5 -exec rm {} \;
}

cvm() {
	tcp $1 ~/.bf
	tsh $1 rm -rf /root/nsujir
	$SCP -r ~/tintri/vmstore-custom/ root@$1:nsujir
	$SSH root@$1 ln -sf /usr/tintri/bin/PlatCmd /root/nsujir/platcmd
	$SSH root@$1 ln -sf /usr/tintri/bin/HAMonCmd /root/nsujir/hamoncmd
	$SSH root@$1 ln -sf /usr/tintri/bin/ProcMonCmd /root/nsujir/procmoncmd
	$SSH root@$1 ln -sf /root/nsujir/isolsetup.sh /usr/local/tintri/bin
	$SSH root@$1 ln -sf /root/nsujir/.profile /root/
	$SSH root@$1 ln -sf /root/nsujir/.bashrc /root/
}

# isolsetup
isols() {
	local target=$1
	local ip=$(ping -c 1 -W 1 $target-ipmi | grep $target | grep PING | grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}')
	local mask=$(ping -c 1 -W 1 $target-ipmi | grep $target | grep PING | grep -o '[0-9]\{1,3\}\.[0-9]\{1,3\}\.')0.1

	tsh $1 "/root/nsujir/isolsetup.sh $ip $mask"
}

zsda() {
	dd if=/dev/zero of=/dev/sda count=16
	sync
}

ZSDA() {
	zsda
	reboot
}

# Link the last built util, fs and ui rpms
lnt() {
	local TOPVER=$($TOPDIR/platform/distro/tools/gen_bldnum $TOPDIR/platform)

	pushd $TOPDIR/distro_bld/local_rpms/RPMS/x86_64 > /dev/null

	local fbase=$(ls -1rt filesystem_base* | tail -n 1)
	local new_fbase=$(echo $fbase | sed 's/[0-9][0-9][0-9][0-9]/'$TOPVER/)
	sudo ln -f $fbase $new_fbase

	local ubase=$(ls -1rt ui_base* | tail -n 1)
	local new_ubase=$(echo $ubase | sed 's/[0-9][0-9][0-9][0-9]/'$TOPVER/)
	sudo ln -f $ubase $new_ubase

	local baseu=$(ls -1rt base_utils* | tail -n 1)
	local new_baseu=$(echo $baseu | sed 's/[0-9][0-9][0-9][0-9]/'$TOPVER/)
	sudo ln -f $baseu $new_baseu

	popd > /dev/null
}

# grep script and usual accessed folders
grs() {
	local sstring=$1
	shift

	dirs=(tools scripts ../distro/*overlay ../distro/spec ../distro/tools $TOPDIR/fs/src $TOPDIR/ui/platform)

	for d in ${dirs[@]}; do
		grep -n -r "$sstring" $@ $d
	done
}

# Upgrade txos
upg() {
	local txos=$1
	local target=$2
	/auto/e2e/bin/UpgradeTools.py install --rpmpath $txos $target
}

# Upgrade to latest <branch>
upgb() {
	local branch=$1 target=$2
	/auto/e2e/bin/UpgradeTools.py install --branch $branch $target
}

# Upgrade to latest default
upgd() {
	local target=$1
	/auto/e2e/bin/UpgradeTools.py install --branch default $target
}

upg_txos() {
	local target=$1
	local rpm=$2

	/bin/ping -c 1 -W 3 ${target} 2>&1 > /dev/null
	if [[ $? -ne 0 ]]; then
		echo "${target} not accessible"
		return 1
	fi

	echo "scp'ing $rpm to $target"
	echo "$SCP $TOPDIR/distro_bld/local_rpms/RPMS/x86_64/$rpm root@${target}:/var/releases/upload"
	$SCP $TOPDIR/distro_bld/local_rpms/RPMS/x86_64/$rpm root@${target}:/var/releases/upload
	if [[ $? -ne 0 ]]; then
		echo "scp failed to controller A"
		return 1
	fi

	echo "Stopping services"
	$SSH root@${target} "/sbin/service postgresql-perf stop"
	$SSH root@${target} "/sbin/service txos stop"

	echo "Starting upgrade_txos on $target"
	$SSH root@${target} "/usr/local/tintri/bin/upgrade_txos -f -F -v -r /var/releases/upload/$rpm"
	if [[ $? -ne 124 ]]; then
		echo "Upgrade failed on $target"
	else
		$SSH root@${target} "reboot"
	fi

}

upgt() {
	if [[ -z $1 || -z $2 ]]; then
		echo "upgt <target> <rpm> [<single>]"
		return 1
	fi

	local target=$1
	local rpm=$(basename $2)
	local single=$3

	local isha=$($SSH root@$target /usr/local/tintri/bin/isha)

	if [[ $isha -eq 0 || $single == "single" ]]; then
		upg_txos $target $rpm
	else
		upg_txos ${target}a $rpm &
		upg_txos ${target}b $rpm
		wait
	fi
}

updb() {
	local target=$1
	/auto/e2e/bin/UpgradeTools.py populatedb $target
}

pxed() {
	local target=$1
	/auto/e2e/bin/rspxeinstall.py pxeinstall --branch default $target
}

hgc0() {
	hg commit -m "bug 0"
}

hgcm() {
	hg commit -m "$@"
}

hgc() {
	hg commit "$@"
}

bb() {
	pushd $TOPDIR/platform/os > /dev/null
	./build.sh build -j $THREADS "$@"
	popd > /dev/null
}

# Build extdrivers
be() {
	local rc
	pushd $TOPDIR/platform/os/extdrivers > /dev/null
	./build.sh build -j $THREADS
	rc=$?
	popd > /dev/null

	return $rc
}

bec() {
	pushd $TOPDIR/platform/os/extdrivers > /dev/null
	./build.sh clean
	popd > /dev/null
}

bi() {
	./build.sh install
}

# Build tools
bt() {
	pushd $TOPDIR/platform/os/tools > /dev/null
	./build.sh build -j $THREADS
	popd > /dev/null
}

btc() {
	pushd $TOPDIR/platform/os/tools > /dev/null
	./build.sh clean
	popd > /dev/null
}

hgd() {
	hg diff

}

mt() {
	local title=$1
	echo -ne "\e]62;$title\a"
}

oob() {
	local target=$1

	ssh root@$target "/usr/bin/java -jar /opt/tintri/thrift_to_soap.jar localhost SystemManagementService setConsoleOobStates true true"
}

sai() {
	local pkgmgr=apt-get

	if [[ -e /usr/bin/dnf ]]; then
		pkgmgr=dnf
	elif [[ -e /usr/bin/yum ]]; then
		pkgmgr=yum
	fi

	sudo $pkgmgr install "$@"
}

syi() {
	sai "$@"
}

syu() {
	local pkgmgr=apt-get

	if [[ -e /usr/bin/dnf ]]; then
		pkgmgr=dnf
	elif [[ -e /usr/bin/yum ]]; then
		pkgmgr=yum
	fi

	sudo $pkgmgr update "$@"
}

sar() {
	local pkgmgr=apt-get

	if [[ -e /usr/bin/dnf ]]; then
		pkgmgr=dnf
	elif [[ -e /usr/bin/yum ]]; then
		pkgmgr=yum
	fi

	sudo $pkgmgr remove "$@"
}

syr() {
	sar "$@"
}

bmclog() {
	local target=$1

	# Remove -ipmi if exists
	target=${target%-ipmi}

	echo "Saving to $target-bmc.log"
	sshpass -p superuser ssh -o StrictHostKeyChecking=no sysadmin@$target-ipmi "BMC_CollectLogs.sh" $target-bmc.log
}

smd() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	local fils=(
		$TOPDIR/kbuild/drivers/md/md-mod.ko
		$TOPDIR/kbuild/drivers/md/raid10.ko
	     )

	$SSH root@${target} iu

	for fil in ${fils[@]} ; do
		$SCP $fil root@${target}:$IRDEXPLODE/lib/modules/$kernel/kernel/drivers/md/
		$SCP $fil root@${target}:/lib/modules/$kernel/kernel/drivers/md/
	done

	$SSH root@${target} iz
	$SSH root@${target} sync
}

sipmi() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	local fils=(
		$TOPDIR/kbuild/drivers/char/ipmi/ipmi_devintf.ko
		$TOPDIR/kbuild/drivers/char/ipmi/ipmi_msghandler.ko
		$TOPDIR/kbuild/drivers/char/ipmi/ipmi_poweroff.ko
		$TOPDIR/kbuild/drivers/char/ipmi/ipmi_si.ko
		$TOPDIR/kbuild/drivers/char/ipmi/ipmi_watchdog.ko
	     )

	$SSH root@${target} iu

	for fil in ${fils[@]} ; do
		$SCP $fil root@${target}:$IRDEXPLODE/lib/modules/$kernel/kernel/drivers/char/ipmi/
		$SCP $fil root@${target}:/lib/modules/$kernel/kernel/drivers/char/ipmi/
	done

	$SSH root@${target} iz
	$SSH root@${target} sync
}

sha() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	local fils=(
		extdrivers/hactl/hactl.ko
	     )

	$SSH root@${target} iu

	for fil in ${fils[@]} ; do
		$SCP $fil root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/
		$SCP $fil root@${target}:
	done

	$SSH root@${target} iz
	$SSH root@${target} sync
}

scs() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	local fils=(
		extdrivers/diskdump/diskdump.ko
		extdrivers/lsi/mpt3sas-4.00.00.00/mpt3sas/mpt3sas.ko
	     )

	$SSH root@${target} iu

	for fil in ${fils[@]} ; do
		$SCP $fil root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/
		$SCP $fil root@${target}:
	done

	$SSH root@${target} iz
	$SSH root@${target} sync
}

# Update custom vmlinuz on a system.
# NOTE: You have to ensure that it matches the vermagic of modules
scv() {
	local target=$1
	$SCP $TOPDIR/kbuild/install.d/vmlinuz root@${target}:/boot
	$SCP $TOPDIR/kbuild/install.d/vmlinux root@${target}:/boot

	$SSH root@${target} mbd

	local vml=$( $SSH root@${target} grep vmlinuz $BDOM_MNT/grub/grub.conf | head -n 1 | awk {'print $2;'} )
	$SCP $TOPDIR/kbuild/install.d/vmlinuz root@${target}:$BDOM_MNT/$vml
	$SSH root@${target} ubd
	$SSH root@${target} sync
}

scd() {
	local target=$1
	local fils=(
		#$TOPDIR/platform/os/tools/scripts/cmn_funcs
		#$TOPDIR/platform/os/tools/scripts/init_disks
		#$TOPDIR/platform/os/tools/diskmgt/list_disks
		#$TOPDIR/platform/os/tools/diskmgt/disksig
		#$TOPDIR/platform/os/scripts/tools/disksig-install
		#$TOPDIR/platform/os/tools/scripts/partition_hdd
		#$TOPDIR/platform/os/tools/scripts/partition_haboot
		#$TOPDIR/platform/os/tools/scripts/partition_md
		#$TOPDIR/platform/os/tools/scripts/verify_mdpsize
		#$TOPDIR/platform/os/tools/scripts/create_md
		#$TOPDIR/platform/os/tools/scripts/boot_check
		#$TOPDIR/platform/os/tools/scripts/inst_grub
		#$TOPDIR/platform/os/tools/scripts/inst_bootfiles
		#$TOPDIR/platform/os/tools/scripts/assemble_md
		#$TOPDIR/platform/os/tools/bootctl/boot_fsck
		$TOPDIR/kbuild/drivers/misc/enclosure.ko
		$TOPDIR/kbuild/drivers/scsi/ses.ko
		);

	for fil in ${fils[@]} ; do
		$SCP $fil root@$1:
	done
	$SSH root@${target} sync
}

scn() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	$SSH root@${target} iu

	$SCP extdrivers/nvx/nvx.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/

	$SSH root@${target} iz
	$SSH root@${target} sync
}

srpmc() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	(
		set -o errexit

		$SCP extdrivers/nvx/nvx.ko root@${target}a:/lib/modules/$kernel/extra/
		$SCP extdrivers/pmc/PMC_Linux_NVMe_Driver_1_0_1/pmc.ko root@${target}a:/lib/modules/$kernel/extra/

		$SCP extdrivers/nvx/nvx.ko root@${target}b:/lib/modules/$kernel/extra/
		$SCP extdrivers/pmc/PMC_Linux_NVMe_Driver_1_0_1/pmc.ko root@${target}b:/lib/modules/$kernel/extra/

		ssh root@${target} sync
	)
	return $?
}

SRPMC() {
	local target=$1

	srpmc ${target}a && $SSH root@${target}a reboot
	srpmc ${target}b && $SSH root@${target}b reboot
}

spm() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	$SSH root@${target} iu

	$SCP extdrivers/nvx/nvx.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/
	$SCP extdrivers/nvx/nvx.ko root@${target}:/lib/modules/$kernel/extra/
	$SCP extdrivers/pmc/PMC_Linux_NVMe_Driver_1_0_1/pmc.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/
	$SCP extdrivers/pmc/PMC_Linux_NVMe_Driver_1_0_1/pmc.ko root@${target}:/lib/modules/$kernel/extra/

	$SSH root@${target} iz
	$SSH root@${target} sync
}

SCN() {
	local target=$1
	scn $target
	$SSH root@${target} reboot
}

scix() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	$SCP extdrivers/intel/enet/ixgbe-3.11.33/src/ixgbe.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/kernel/drivers/net/ixgbe/
	$SCP extdrivers/intel/enet/ixgbe-3.11.33/src/ixgbe.ko root@${target}:/lib/modules/$kernel/kernel/drivers/net/ixgbe/

	$SSH root@${target} sync
}

SCIX() {
	local target=$1
	scix $target
	$SSH root@${target} rmmod ixgbe
	$SSH root@${target} modprobe ixgbe
}

scnv() {
	local target=$1

	$SCP $TOPDIR/bld_rs/src/prog/nvperf/nvperf root@${target}a:
	$SCP $TOPDIR/bld_rs/src/prog/nvperf/nvperf root@${target}b:
	$SSH root@${target} sync
}

smir() {
	local target=$1

	$SCP $TOPDIR/platform/os/tools/nvram/nvx root@${target}a:/tmp
	$SCP $TOPDIR/platform/test/nvram/mirtest.sh root@${target}a:/tmp
	$SCP $TOPDIR/platform/test/nvram/nvmir root@${target}a:/tmp
	$SCP $TOPDIR/bld_rs/src/prog/nvperf/nvperf root@${target}a:

	$SCP $TOPDIR/platform/os/tools/nvram/nvx root@${target}b:/tmp
	$SCP $TOPDIR/platform/test/nvram/mirtest.sh root@${target}b:/tmp
	$SCP $TOPDIR/platform/test/nvram/nvmir root@${target}b:/tmp
	$SCP $TOPDIR/bld_rs/src/prog/nvperf/nvperf root@${target}b:
}

scnvd() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	#$SSH root@${target} "/sbin/ifdown bondinternal0"
	#$SSH root@${target} "/sbin/rmmod xyvnic"
	#$SSH root@${target} iu

	#$SCP extdrivers/agiga/madura-1.0/driver/agigaram.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/
	#$SCP extdrivers/xyratex/xybridge/trunk/source/xyvnic/xyvnic.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/xyvnic
	#$SCP extdrivers/xyratex/xybridge/trunk/source/xymir/ntb_mir.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/xymir/
	#$SCP extdrivers/xyratex/xybridge/trunk/source/xybridge/xybridge.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/xybridge/
	#$SCP extdrivers/agiga/nvdimm_mir/nvdimm_mir.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/


	$SCP extdrivers/agiga/madura-1.0/driver/agigaram.ko root@${target}:/lib/modules/$kernel/extra/
	$SCP extdrivers/xyratex/xybridge/trunk/source/xyvnic/xyvnic.ko root@${target}:/lib/modules/$kernel/extra/xyvnic/
	$SCP extdrivers/xyratex/xybridge/trunk/source/xymir/ntb_mir.ko root@${target}:/lib/modules/$kernel/extra/xymir/
	$SCP extdrivers/xyratex/xybridge/trunk/source/xybridge/xybridge.ko root@${target}:/lib/modules/$kernel/extra/xybridge/
	$SCP extdrivers/agiga/nvdimm_mir/nvdimm_mir.ko root@${target}:/lib/modules/$kernel/extra/

	$SSH root@${target} "service xybridge restart"
	$SSH root@${target} "/sbin/ifup bondinternal0"

	#$SSH root@${target} iz
	$SSH root@${target} sync
}

scag() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	$SSH root@${target} iu

	$SCP extdrivers/agiga/madura-1.0/driver/agigaram.ko root@${target}:$IRDEXPLODE/lib/modules/$kernel/extra/
	$SCP extdrivers/agiga/madura-1.0/driver/agigaram.ko root@${target}:/lib/modules/$kernel/extra/

	$SSH root@${target} iz
	$SSH root@${target} sync
}

scdis() {
	local target=$1
	local kernel=$( $SSH root@${target} uname -r )

	$SCP extdrivers/diskdump/diskdump.ko root@${target}:
	$SSH root@${target} /sbin/rmmod diskdump
	$SSH root@${target} /sbin/insmod /root/diskdump.ko
	$SSH root@${target} /usr/local/tintri/bin/config_dump -c -v

	$SSH root@${target} sync
}

scin() {
	local target=$1

	$SSH root@${target} iu

	$SCP $TOPDIR/platform/distro/initrd_overlay/init root@${target}:$IRDEXPLODE/

	$SSH root@${target} iz
	$SSH root@${target} sync
}

REINS() {
	local target=$1

	$SSH root@${target} mbd
	$SSH root@${target} mkdir -p $BDOM_MNT/reinstall
	$SSH root@${target} touch $BDOM_MNT/reinstall/$(date +%F)
	$SSH root@${target} touch $BDOM_MNT/reinstall/$(date +%b%a%j)
	$SSH root@${target} "echo devpassword=tintri99 > $BDOM_MNT/reinstall/cmdline"

	$SSH root@${target} ubd
	$SSH root@${target} sync
}

# Generate ssh keys and setup auto login on target
tsa() {
	local target=$1

	if [[ ! -e $HOME/.ssh/id_rsa.pub ]]; then
		ssh-keygen -f $HOME/.ssh/id_rsa -N ''
	fi

	tsa.exp $target
}

